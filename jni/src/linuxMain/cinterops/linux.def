headers = unistd.h fcntl.h errno.h string.h signal.h pthread.h sys/socket.h sys/wait.h X11/Xlib.h dbus/dbus.h
linkerOpts = -ldbus-1 -lX11

---
#include <unistd.h>
#include <dirent.h>
#include <string.h>

inline static void set_errno(int v) {
    errno = v;
}

inline static int fork_exec(
        int fd,
        char *const *arguments,
        char *const *environments,
        int working_dir,
        int extra_fds[],
        int stdin_fd,
        int stdout_fd,
        int stderr_fd
) {
    pid_t pid = fork();
    switch (pid) {
        case -1: {
            return -1;
        }
        case 0: {
            if (working_dir >= 0 && fchdir(working_dir) < 0) {
                abort();
            }

            if (STDIN_FILENO != stdin_fd && dup2(STDIN_FILENO, stdin_fd) < 0) {
                abort();
            }

            if (STDOUT_FILENO != stdout_fd && dup2(STDOUT_FILENO, stdout_fd) < 0) {
                abort();
            }

            if (STDERR_FILENO != stderr_fd && dup2(STDERR_FILENO, stderr_fd) < 0) {
                abort();
            }

            DIR *dir = opendir("/proc/self/fd");
            if (dir) {
                struct dirent *entry;
                while ((entry = readdir(dir))) {
                    if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
                        continue;
                    }

                    int current_fd = (int) strtol(entry->d_name, NULL, 10);
                    if (current_fd == fd ||
                        current_fd == STDIN_FILENO ||
                        current_fd == STDOUT_FILENO ||
                        current_fd == STDERR_FILENO) {
                        continue;
                    }

                    for (int *p = extra_fds; *p != -1; p++) {
                        if (*p == current_fd) {
                            current_fd = -1;
                            break;
                        }
                    }

                    if (current_fd >= 0) {
                        close(current_fd);
                    }
                }
                closedir(dir);
            }

            if (fexecve(fd, arguments, environments) < 0) {
                perror("fexecve");

                abort();
            }

            return 1;
        }
        default: {
            return pid;
        }
    }
}
